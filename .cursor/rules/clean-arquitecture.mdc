---
alwaysApply: true
---


# ðŸŸ¢ Clean & Maintainable Flutter Architecture

## ðŸ“œ General Principle
> **Every project component must have a single, well-defined responsibility (SRP), be properly isolated, and clearly express its purpose at first glance.**  
> The architecture should promote **scalability, maintainability, readability, and testability**.

This rule **must always be applied** when developing new features, extending existing functionality, or refactoring code.

---

## ðŸ“‚ Recommended Project Structure

Organize the project **by features**.  
Each feature should have its own subfolders to separate concerns:


### Folder Responsibilities
- **models/** â†’ Pure data classes (e.g., DTOs, entities, value objects).
- **interfaces/** â†’ Contracts defining the behavior of services, repositories, or data sources.
- **services/** â†’ Implementations of business logic and data persistence (e.g., API calls, Hive/Firestore integration).
- **notifiers/** â†’ State management using `StateNotifier` / `Notifier` (Riverpod recommended).
- **pages/** â†’ Full-screen UI compositions that depend on notifiers.
- **widgets/** â†’ Reusable UI components without business logic.
- **bottom_sheets/** â†’ Reusable modal components (e.g., `CustomAppBottomSheet`).
- **routes/** â†’ Centralized route and navigation definitions.

---

## ðŸ“ Core Principles

### 1. **Single Responsibility Principle (SRP)**
- Each class, function, and file must do **only one thing**.
- Do **not mix** business logic with presentation code.

---

### 2. **Separation of Concerns**
- **Services** â†’ handle data retrieval and business rules.  
- **Notifiers** â†’ manage and expose state to the UI.  
- **Widgets/Pages** â†’ focus solely on rendering data and user interaction.

---

### 3. **Dependency Inversion**
- Depend on **interfaces**, not on concrete implementations.
- Example: inject `PurchaseRepository` interface into a notifier or service instead of using the concrete implementation directly.

---

### 4. **Prefer Immutability**
- Make models and states **immutable** where possible.
- Use `copyWith()` to produce new state or data objects.
- Reduces side-effects and simplifies debugging.

---

### 5. **Reusability and Composition**
- Build **small, composable widgets** instead of large, monolithic components.
- Reuse common components such as buttons, banners, and product cards in the `widgets` folder.

---

### 6. **Keep Business Logic Out of the UI**
- Avoid putting data manipulation, validation, or networking code inside widgets or pages.
- Widgets should only **render data** and react to user interactions.

---

### 7. **Clear and Consistent Naming**
- Use meaningful names that communicate the componentâ€™s responsibility.
  - âœ… `PurchaseService`, `BatchPurchaseNotifier`, `CartItemModel`
  - âŒ `DataHandler`, `Utils`, or ambiguous abbreviations.

---

### 8. **Extensibility and Scalability**
- New features should be easy to add **without breaking existing code**.
- Extend the system by adding new services, notifiers, or models rather than modifying existing ones unnecessarily.

---

### 9. **Testing-Friendly Design**
- Decoupled services, notifiers, and models make it straightforward to write **unit tests** and **integration tests**.
- The UI should be testable in isolation from business logic.

---

## ðŸ”Ž Example: Batch Purchases Feature

A properly structured feature for **Batch Purchases** could look like this:


- **Model** â†’ `BatchPurchaseModel`  
  Stores data such as `label`, `createdAt`, `products`, `lastUsedAt`.

- **Interface** â†’ `BatchPurchaseRepository`  
  Defines operations like `fetchAll`, `addBatch`, `updateBatch`, `deleteBatch`.

- **Service** â†’ `BatchPurchaseService`  
  Implements persistence using Hive and optionally synchronizes with a remote source.

- **Notifier** â†’ `BatchPurchaseNotifier`  
  Exposes application state (list of batches, loading states, errors).

- **Widgets** â†’ `BatchPurchaseCard`  
  Renders a single batch purchase in a list.

- **Page** â†’ `BatchPurchasePage`  
  Displays the list of all saved batches and connects to the notifier.

- **Bottom Sheet** â†’ `BatchPurchaseSelectorSheet`  
  Allows selecting products to add to a batch purchase with a searchable modal UI.

---

## ðŸš« Common Pitfalls to Avoid
- âŒ Mixing business logic and UI code.  
- âŒ Writing massive â€œgod classesâ€ that handle unrelated responsibilities.  
- âŒ Accessing databases (Hive, Firestore, etc.) directly in widgets or pages.  
- âŒ Using vague or inconsistent naming conventions.  
- âŒ Skipping interfaces, making testing and swapping implementations harder.

---

## âœ… Summary for Contributors
When adding or modifying code:
1. Identify the **type of component** (model, service, notifier, widget, etc.).
2. Place it in the **correct folder** within the corresponding feature.
3. Ensure it follows **SRP** and does **not mix concerns**.
4. Use **interfaces** to abstract dependencies.
5. Keep **UI components purely presentational**.
6. Write **tests** for business logic whenever possible.

---

## ðŸ— Benefits of This Architecture
- ðŸ“¦ **Modular & Scalable** â€” New features can be added easily.
- ðŸ” **Readable & Maintainable** â€” Clear separation of layers.
- âœ… **Testable** â€” Easy to test services and state without UI dependencies.
- ðŸ”„ **Replaceable** â€” Swap out data sources or services with minimal code changes.
- ðŸš€ **Future-Proof** â€” Supports growth and complexity over time.

---

> Following this rule ensures a **clean, maintainable, and professional-grade Flutter application**, suitable for teams and long-term projects.

